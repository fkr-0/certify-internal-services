#!/usr/bin/env python3
"""
cert_manager.py  –  ACME + dnsmasq + deployment supervisor
Execution modes:
    python3 cert_manager.py initial   # one-shot on container start
    python3 cert_manager.py renew     # via cron, handles renewals
"""
import argparse, logging, os, subprocess, sys, time, yaml
from logging.handlers import RotatingFileHandler
from pathlib import Path

# ---------- Constants / paths ------------------------------------
LOG_FILE = Path("/data/logs/cert_manager.log")
CONFIG_YML = Path("/config/targets.yml")
DNS_HOSTS = Path("/config/dnsmasq.conf")  # dnsmasq include
ACME_SH = Path("/home/app/.acme.sh/acme.sh")
CERT_DIR = Path("/data/certs")

# ---------- Logging setup (10 × 1 MiB rotate) ---------------------
LOG_FILE.parent.mkdir(exist_ok=True, parents=True)
handler = RotatingFileHandler(LOG_FILE, maxBytes=1_000_000, backupCount=10)
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(levelname)s %(message)s",
    handlers=[handler, logging.StreamHandler(sys.stdout)],
)
log = logging.getLogger(__name__)


# ---------- Helpers ----------------------------------------------
def _run(cmd: list[str], check=True, **kw):
    """Wrapper around subprocess.run with logging."""
    log.debug("RUN %s", " ".join(cmd))
    result = subprocess.run(cmd, capture_output=True, text=True, **kw)
    if result.stdout:
        log.debug(result.stdout.strip())
    if result.stderr:
        log.debug(result.stderr.strip())
    if check and result.returncode != 0:
        raise subprocess.CalledProcessError(
            result.returncode, cmd, result.stdout, result.stderr
        )
    return result


def load_cfg():
    with open(CONFIG_YML, "r") as f:
        return yaml.safe_load(f)


# ---------- DNSMASQ ------------------------------------------------
def update_dnsmasq(cfg):
    """Rewrite dnsmasq.conf with address=/sub.domain/IP entries."""
    lines = [
        "# AUTOGENERATED – DO NOT EDIT\n",
        "no-resolv\n",
        "log-queries\n",
    ]
    for t in cfg["targets"]:
        lines.append(f"address=/{t['subdomain']}.{cfg['domain_root']}/{t['ip']}\n")
    DNS_HOSTS.write_text("".join(lines))
    # SIGHUP dnsmasq so it reloads
    pid_file = Path("/data/dnsmasq.pid")
    if pid_file.exists():
        pid = pid_file.read_text().strip()
        _run(["kill", "-HUP", pid], check=False)
    log.info("dnsmasq configuration updated")


# ---------- ACME & Deploy -----------------------------------------
def ensure_certificate(cfg, target):
    """Issue/renew certificate for <subdomain>.<root>."""
    fqdn = f"{target['subdomain']}.{cfg['domain_root']}"
    cert_path = CERT_DIR / fqdn
    cert_path.mkdir(parents=True, exist_ok=True)
    domain = f"{cfg['domain_root']}"
    subdomain = f"*.{cfg['domain_root']}"
    # acme.sh command line
    cmd = [
        str(ACME_SH),
        "--issue",
        "--dns",
        cfg.get("acme_dns_provider", "dns_manual"),
        "-d",
        domain,
        "-d",
        subdomain,
        "--home",
        str("/root/.acme.sh"),
        "--cert-home",
        str(cert_path),
        "--accountemail",
        cfg["acme_contact_email"],
        "--keylength",
        "ec-256",
    ]
    try:
        _run(cmd)
        log.info("Certificate OK for %s", domain)
        log.info("Certificate OK for %s", subdomain)
        return (cert_path / f"{domain}.cer", cert_path / f"{subdomain}.cer")
    except subprocess.CalledProcessError as exc:
        log.error("acme.sh failed for %s → %s", fqdn, exc.stderr.strip())
        return None


def deploy_cert(cert_file: Path, target):
    """Dispatch certificate using chosen method (scp, rsync, cp…)."""
    if not cert_file or not cert_file.exists():
        log.warning("Skip deploy – no certificate")
        return
    d = target["deploy"]
    method = d["method"]
    if method == "scp":
        _run(["scp", "-i", d["ssh_key"], str(cert_file), d["destination"]])
    elif method == "rsync":
        _run(
            [
                "rsync",
                "-avz",
                "--rsh=ssh -i " + d["ssh_key"],
                str(cert_file),
                d["destination"],
            ]
        )
    elif method == "cp":
        Path(d["destination"]).parent.mkdir(parents=True, exist_ok=True)
        _run(["cp", str(cert_file), d["destination"]])
    else:
        log.error("Unknown deploy method %s", method)
        return
    log.info("Deployed cert → %s (%s)", d["destination"], method)


# ---------- Main entrypoints --------------------------------------
def initial():
    cfg = load_cfg()
    update_dnsmasq(cfg)
    # First-time cert issuance (non-failing)
    for t in cfg["targets"]:
        ensure_certificate(cfg, t)


def renew():
    cfg = load_cfg()
    update_dnsmasq(cfg)
    for t in cfg["targets"]:
        cert = ensure_certificate(cfg, t)
        deploy_cert(cert, t)


def cli():
    parser = argparse.ArgumentParser()
    parser.add_argument("action", choices=["initial", "renew"])
    args = parser.parse_args()
    try:
        globals()[args.action]()
    except Exception as exc:
        log.exception("Fatal error: %s", exc)
        sys.exit(1)


if __name__ == "__main__":
    cli()
